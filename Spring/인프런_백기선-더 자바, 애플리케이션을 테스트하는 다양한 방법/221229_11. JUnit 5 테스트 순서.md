> ⚡ 생각대로 살지 않으면 사는대로 생각한다.
> ⚡ 나는 어차피 잘 될 놈이다. 이미 잘 되고 있고, 계속해서 잘 되고 있다.

---

> 테스팅 순서는 내부적으로 정해진 순서가 있다. 그래서 항상 그 순서대로 진행되게끔 되어있다. 
그렇지만, 테스트 수행시 그 순서에 의존해서는 안 되고, 순서는 항상 바뀔 수 있다는 것을 염두에 두어야한다.

> JUunit에서 순서방식을 드러내지 않은 의도는 테스트가 하나의 단위라면, **각 단위테스트는 다른 단위테스트들과는 독립적으로 수행되어야 한다.** 즉 다른 단위테스트와는 **의존성이 없어야 한다.**
**어떤 코드를 실행했던 간에, 다른 테스트 코드에 영향을 주면 안 된다.**
그래서 순서를 생각하거나 의존하지 않는 것이 좋다.

하지만 경우에 따라서는 원하는 순서대로 테스트를 작성하고 필요도 있다. 
예를 들어서, `회원가입-> 로그인 -> 개인 페이지- > 닉네임 변경`과 같은 시나리오를 테스트하려고 할 때, 
테스트 수행시점마다 테스트의 상태정보를 유지하고, 각 테스트 간의 의존성을 가지며, 데이터를 공유하려면, 각 테스트 메서드마다 새로운 인스턴스를 생성하는 방식으로 테스트를 진행하게 하는 것이 아니라, [이전 글](https://velog.io/@tjdtn4484/10.-JUnit-5-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4)에 다뤘던 내용처럼 테스트 인스턴스를 하나로만 생성되게 해서 **@TestMethodOrder()**애너테이션을 이용해서, **MethodOrderer 인터페이스**를 구현한 클래스를 값으로 넣어주면, `마치 자바의 정렬 인터페이스 **Comparator**를 구현한 클래스를 넣어주면, 순차적으로 정렬되는 것처럼,` **테스트 메서드를 순차적으로 수행**되게 할 수 있다.

순서를 지정하는 구현체로는 아래의 3가지 구현체가 있다.
* Alphanumeric
* **OrderAnnoation**
* Random


`(본 강의에서는 OrderAnnotation만 짚고 넘어감.)`
>**@OrderAnnotation**을 사용하면, **@Order**애너테이션을 이용해서 순서를 정해줄 수 있다.
> ※ **@Order**에너테이션의 라이브러리를 import 할 때, `org.springframework`가 제공하는 라이브러리가 아닌, `junit`이 제공하는 라이브러리를 받아와야 한다.

> **@Order(int() value)**에서 순서를 적용할 때, 두개의 메서드에 똑같은 순서값을 지정했다면, 오류가 나오는 것이 아니라, 나름의 내부적인 알고리즘을 통해서, 순서대로 테스트를 수행한다. 
![](https://velog.velcdn.com/images/tjdtn4484/post/da2f687a-7a0a-4c28-87ce-01082c8a0c2a/image.png)


> 💡참고
앞에 선언했던, **@TestInstance(TestInstance.Lifecycle.PER_CLASS)**를 없애더라도, Order는 적용된다. 
꼭 같이 쓸 필요는 없지만, 같이 사용하면 좋다.. 
동일한 인스턴스 내에서 상태정보를 공유하면서, 시나리오 테스트를 작성할 대 유용하다.

---
-끝-

