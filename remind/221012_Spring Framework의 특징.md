후.. 소화하려면 시간 좀 걸릴 거 같은 파트다.. 거의 자바의 객체지향 개념과 멀지않다고 느끼지만, 응요할 줄 알려면, 또 삽질을 해야겠지...
어차피 잘 되기 위해,, 삽질 좀 하고싶다.


---
# Spring Framework의 특징

## POJO(Plain Old Java Object)

![](https://velog.velcdn.com/images/tjdtn4484/post/dc97ab5c-d4ea-418d-9a34-e33d7e766d37/image.PNG)

위 그림은 Spring의 핵심 개념을 모두 표현을 하고 있다고 해도 과언이 아니다.
* POJO는 IoC/DI,AOP,PSA를 통해서 달성할 수 있다는 것을 의미
* POJO는 Plain Old Java Object라는 단어의 첫글자를 따서 만든 약자
* Java로 생성하는 순수한 객체를 의미한다.

### POJO 프로그래밍
* POJO를 이용해서 프로그래밍 코드를 작성하는 것을 의미한다.
`하지만 단순히 순수 자바 객체만을 사용해서 프로그래밍 코드를 작성한다고 해서 POJO 프로그래밍이라고 볼 수는 없다.`

#### POJO 프로그래밍으로 작성한 코드로 불리기 위한 두가지의 기본적인 규칙
* Java나 Java의 스펙(사양)에 정의된 것 이외에는 다른 기술이나 규약에 얽매이지 않아야 한다.
  * 예를 들면, 그냥 순수한 자바 언어로 쓰여진 코드라는 의미
* 특정 환경에 종속적이지 않아야 한다.
  * 예를 들면, 개발시 시스템의 요구사항이 변경될 때, 기존의 코드를 뜯어고쳐야되는 일이 발생하지 않아야 한다는 의미.

#### POJO 프로그래밍의 필요성
* 특정 환경이나 기술에 종속적이지 않으면 재사용 가능하고, 확장 가능한 유연한 코드를 작성할 수 있다.
* 저수준 레벨의 기술과 환경에 종속적인 코드를 애플리케이션 코드에서 제거 함으로써 코드가 깜끔해진다.
* 코드가 깔끔해지기 때문에, 디버깅하기도 상대적으로 쉽다.
* 특정 기술이나 환경에 종속적이지 않기 때문에 테스트 역시 단순해진다.
* **객체지향적인 설계를 제한없이 적용할 수 있다.** (가장 중요하다.)

## POJO와 Spring의 관계
* Spring은 POJO 프로그래밍을 지향하는 Framework
* POJO프로그래밍을 지향하는 Spring의 세 가지 기술
  * IoC/DI
  * AOP
  * PSA


> POJO프로그래밍을 하면서 항상 가져야 될 고민과 습관은
   지금 작성한 코드가 객체지향스러운가에 대한 고민을 늘 해야한다.

# POJO 정리
* POJO란 순수한 Java 객체를 의미
* POJO 프로그래밍이란 순수 Java객체가 다른 기술이나 환경에 종속되지 않도록 하기 위한 프로그래밍 기법
* POJO 프로그래밍을 효과적으로 적용하기 위해서는 특정 기술에 대한 지식보다는 JDK의 API에 대한 지식과 객체지향적인 사고방식과 설계를 위한 훈련이 우선시 되어야 한다.
* Spring Framework은 POJO 프로그래밍을 지향하기 위해 IoC/DI, AOP, PSA 라는 기술을 제공한다.


## IoC(Inversion of Control) 
제어의 역전
애플리케이션 흐름의 주도권을 Spring이 갖는다.
즉, **애플리케이션 흐름의 주도권이 뒤바뀐 것**이 IoC(Inversion of Control)이라고 한다.

Spring에서 IoC의 개념이 어떻게 적용되었을까? 바로 DI(Dependency Injection) 덕분이다.

##  DI(Dependency Injection)
의존성 주입..
IoC의 개념을 조금 더 구체화 시킨 것이다.

* 단어의 의미로 DI 이해하기
 * Dependency는 `의존하는 또는 종속되는`이라는 의미를 가지고 있다.
 * Injection은 `주입`이라는 의미를 가지고 있다. (병원에서 맞는 주사를 Injection이라고 함)

#### 의존성 주입을 육하원칙에 맞춰서 분석해보기.

1. What(의존성 주입이란?)
**객체지향 프로그래밍에서의 의존성**은 대부분 객체 간의 의존성을 의미한다.
예를 들어, A,B라는 두 개의 클래스가 있고, A 클래스에서 B 클래스의 기능을 사용한다고 가정했을 때, `"A클래스는 B클래스에 의존한다."`라고 한다.

그냥..하나의 클래스가 다른 클래스의 기능을 사용할 때, 의존한다라고 함.

>참고! 클라이언트 측면에서 서버의 **엔드포인트(Endpoint)**란 클라이언트가 서버의 자원(리소스, Resource)을 이용하기 위한 끝지점을 의미한다.

**클래스끼리** **사용하고자 하는 클래스**의 **객체를 생성**해서 **참조**하게 되면 이는 **의존 관계가 성립**되는 것이다.

의존성 주입( 의존 관계가 성립되었다고 해서, 의존성 주입이 이루어진 것은 아니다.)
* 생성자를 통해서 어떤 클래스의 객체를 전달받는 것을 **의존성 주입**이라고 한다.
* 생성자의 파라미터로 객체를 전달하는 것을 **`외부`에서 객체를 주입한다**라고 표현을 한다.
  * 여기서 **외부**란, A, B 클래스들이 의존 관계를 성립했다고 가정하고, 전혀 다른 C 클래스가 서로 의존관계가 성립된 A, B클래스를 통해서 객체를 전달한다고 가정했을 때, **외부**는 **C클래스**를 의미한다.



2. Why(의존성 주입은 왜 필요할까?)

의존성 주입을 사용할 때, 항상 염두에 두어야 하는 부분.

> 현재의 클래스 내부에서 외부 클래스의 객체를 생성하기 위한 `new`키워드를 쓸지 말지 여부를 결정하는 것.

애플리케이션 코드 내부에서 직접적으로 `new`키워드를 사용할 경우 객체지향 설계의 관점에서 중요한 문제가 발생할 수 있다.

> 참고! Stub(스텁)은 메서드가 호출되면 미리 준비된 데이터를 응답하는 것이다. 고정된 데이터이기 때문에 몇번을 호출해도 동일한 데이터를 리턴한다.
  몇번을 호출해도 동일한 데이터를 리턴하는 것을 전문 용어로 **멱등성(idempotent)을 가진다**라고 함.

* `new`키워드를 사용해서 의존 객체를 생성할 때, 클래스 간에 **강하게 결합(Tight Coupling)**되어 있다라고 한다.

* 결론적으로 의존성 주입을 하더라도, **의존성 주입의 혜택**을 보기 위해선 **클래스들 간의 강한 결합**은 **피하는 것**이 **좋다.**
* 느슨한 결합(Loose Coupling)이 필요하다.

```
애플리 케이션의 요구사항은 언제든 변할 수 있기 때문에, **"이렇게 작성해 놓으면 또 수정이 필요한 부분이 뭐가 있을까?"** 라는 생각을 한 번쯤은 해보는 것이 좋다.
```


3. How(느슨한 의존성 주입은 어떻게 할까?)

느슨한 결합을 위한 대표적인 방법이 인터페이스(Interface)를 사용하는 것이다.
* 어떤 클래스가 인터페이스 같이 일반화된 구성 요소에 의존하고 있을 때, 클래스들 간의 느슨하게 결합(Loose Coupling)되어있다고 한다.

업캐스팅을 통한 의존성 주입으로 인해 느슨한 결합 관계를 유지하게 된다.



4. Who(Spring 기반 애플리케이션에서는 의존성 주입을 누가 해줄까?)
Spring이 의존 객체들을 주입한다.

>참고! main() 메서드처럼 애플리케이션이 시작되는 지점을 엔트리 포인트(Entry point)라고 부른다.


### 정리
* 애플리케이션 흐름의 주도권이 사용자에게 있지 않고, Framework나 서블릿 컨테이너 등 외부에 있는 것, 즉 흐름의 주도권이 뒤바뀐 것을 IoC(Inversion of Control)라고 한다.
* DI(Dependency Injection)는 IoC 개념을 조금 구체화 시킨 것으로 객체 간의 관계를 느슨한게 해준다.
* 클래스 내부에서 다른 클래스의 객체를 생성하게 되면 두 클래스 간에 의존관계가 성립하게 된다.
* 클래스 내부에서 `new`를 사용해서 참조할 클래스의 객체를 직접 생성하지 않고, 생성자 등을 통해 외부에서 다른 클래스의 객체를 전달받고 있다면 의존성 주입이 이루어지고 있는 것.
* `new`키워드를 사용하여 객체를 생성할 때, 클래스 간에 **강하게 결합(Tight Coupling)**되어 있다고 한다.
* 어떤 클래스가 인터페이스 같이 일반화 된 구성 요소에 의존하고 있을 때, 클래스들 간에 **느슨하게 결합(Loose Coupling)되어있다고 한다.
* 객체들 간의 느슨한 결합은 요구 사항의 변경에 유연하게 대처할 수 있도록 해준다.
* 의존성 주입(DI)은 클래스들 간의 강한 결합을 느슨한 결합으로 만들어준다.
* Spring에서는 애플리케이션 코드에서 이루어지는 의존성 주입(DI)을 Spring에서 대신 해준다.


## AOP(Aspect Oriented Programming)

한국어 번역시 '관심 지향 프로그래밍' 정도로 해석 가능.
애플리케이션에 필요한 기능 중에서 공통적으로 적용되는 공통 기준에 대한 관심과 관련있음.

### 공통 관심 사항과 핵심 관심 사항
* 애플리케이션 전반에 걸쳐 공통적으로 사용되는 공통 기능들에 대한 관심사를 **공통 관심 사항(Cross-cutting concern)**이라고 한다.

* 비즈니스 로직 즉, 애플리케이션의 주목적을 달성하기 위한 핵심 로직에 대한 관심사를 **핵심 관심 사항(Core concern)**이라고 한다.

> 핵심 관심 사항에 반대되는 개념으로 **공통 관심 사항**을 **부가적인 관심 사항**이라고 표현하기도 함.

##### 정리
* AOP라는 것은 애플리케이션의 핵심 업무 로직에서 로깅이나 보안, 트랜잭션 같은 공통 기능 로직을들 분리하는 것이라고 생각하면 된다.

### AOP의 당위성(=필요한 이유)
AOP를 활용하면 애플리케이션 전반에 걸쳐 적용되는 공통 기능(트랜잭션, 로깅, 보안, 트레이싱, 모니터링) 등을 비지니스 로직에서 깔끔하게 분리하여 재사용 가능한 모듈로 사용할 수 있다.

##### 정리
* AOP(Aspect Oriented Programming)는 관심 지향 프로그래밍이다.
* AOP에서 의미하는 Aspect는 애플리케이션의 공통 관심사를 의미한다.
* 애플리케이션의 공통 관심사는 비지니스 로직(=핵심 관심사항)을 제외한 애플리케이션 전반에 걸쳐서 사용되는 공통 기능들을 의미한다.
* 애플리케이션 전반에 걸쳐서 사용되는 공통 기능에는 로깅, 보안, 트랜잭션, 모니터링, 트레이싱 등의 기능이 있다.
* AOP를 애플리케이션에 적용해서 다음과 같은 이점을 누릴 수 있다.
  * 코드의 간결성 유지
  * 객체 지향 설계 원칙에 맞는 코드 구현
  * 코드의 재사용

## PSA(Portable Service Abstraction)

클라이언트가 **추상화 된 상위 클래스를 일관되게 하위 클래스의 기능을 사용하는 것이 바로 일관된 서비스 추상화(PSA)의 기본 개념**이다.
* 즉 일관된 방식으로 해당 서비스의 기능을 사용할 수 있다는 의미
  * 인터페이스를 통해서 서로 다른 구현체(객체)를 얻겠지만, 서로 다른 구현체(객체)를 얻었다해도, 동일한 기능을 가진 서비스를 사용할 수 있다는 의미이다.

* **서비스의 기능을 접근하는 방식 자체를 일관되게 유지하면서 기술 자체를 유연하게 사용할 수 있도록 하는 것을 PSA(일관된 서비스 추상화)라고 한다.**


### PSA가 필요한 이유
어떤 서비스를 이용하기 위한 접근 방식을 일관된 방식으로 유지함으로써 애플리케이션에 사용하는 기술이 변경되더라도 최소한의 변경만으로 변경된 요구 사항을 반영하기 위한 것이다. 
즉, PSA(일관된 서비스 추상화)를 통해서 애플리케이션의 요구 사항 변경에 유연하게 대처할 수 있다.
