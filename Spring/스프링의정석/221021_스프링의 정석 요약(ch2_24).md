# Intro
말이 요약이지..그냥 내용 정리다..
~~ㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋ~~

# ch2_24

서로 관련된 요청(+응답)들을 하나로 묶은 것 - 쿠키를 이용.

* 원래 요청은 각각 독립적
  * 독립적 : 서로의 요청간의 관계가 없다.는 의미..
* **독립적인 요청들을 하나로 묶은 것**이 **세션**이고, 그러기 위해서, `쿠키`를 이용한다. 
* 브라우저마다 개별 저장소(session객체)를 서버에서 제공한다.
  * 브라우저**마다** 세션객체가 생기는 이유는 바로 쿠키 때문이다. 
  * 쿠키가 브라우저에 저장되기 때문에..브라우저마다 하나의 세션 객체가 만들어진다.
* 영어로 된 설명으로 세션을 정의하자면, 서로 관련된 요청/응답(HTTP Transaction)을 모아놓은 것을 세션이라고 한다.
* 그리고 하나의 서버에 하나의 브라우저가 1:1 관계를 가진다.

### 흐름
클라이언트가 서버로 요청을 보내면, 
	// 서버는 쿠키를 생성하고 ,
	// 그 쿠키에 세션 ID를 추가해서, 
	// 클라이언트로 응답한다.
그리고 클라이언트가 서버로 **또** 요청을 보내게 되면, 이전의 요청과는 엄연히 다른 요청이지만, 
쿠키와, 쿠키에 있는 세션 아이디 덕분에, 동일한 클라이언트로부터 요청을 받은 것인지 서버에서 구분이 가능하다..

같은 세션에 포함되어 있는 동안 세션 저장소를 사용가능!


### 세션을 끝내는 방법
1. 수동 종료 : `invalidate()`메서드로..
2. 자동 종료 : Time out...

* 세션이 끝나면, 다른 세션ID가 발급된다...

### 세션의 생성 과정

1. 처음에 브라우저가 서버로 요청을 하면, 서버가 무조건 세션 객체(저장소)를 만든다.
2. 세션 객체마다 가지고 있는 세션 ID를 쿠키에 담아서 응답한다. 
3. 그럼 브라우저에 쿠키가 저장된다.
4. 이후로, 요청을 보낼 때마다 쿠키가 자동으로 따라간다.
5. 그럼 서버가 세션 ID를 식별해서, 같은 브라우저에서 온 요청인지 아닌지 알 수 있다.
6. 그리고 세션 ID가 같은 객체(저장소)를 사용가능하다.

* **Controller**에서 세션 저장소를 사용하는법
```
HttpSession session = request.getSession();
session.setAttribute("id","asdf");
```
컨트롤러에서 위와 같은 코드가 있을 때,
**request**가 보이는 것과 같이 요청 정보에서 일치하는 세션ID를 찾는다.
그리고, 세션 ID와 일치하는 세션 저장소(객체)를 찾아서, 저장소에 map형식으로 "id"와 "asdf"를 Key, Value로 저장한다.


> 세션과 관련된 메서드 참고!

|메서드|설명|
|:-|:-|
|String getId()|세션의 ID를 반환|
|long getLastAccessedTime()|세션 내에서 최근 요청을 받은 시간을 반환|
|boolean isNew()|새로 생성된 세션인지를 반환. request.getSession()호출 후 사용|
|void invalidate()|세션 객체를 제거(저장된 객체도 함께) - logout할 때 사용.|
|void setMaxInactiveInterval(int interval)|지정된 시간(초)후에 세션을 종료(예약 종료)|
|int getMaxInactiveInterval()|예약된 세션 종료 시간을 반환|

---

|속성 관련 메서드|설명|
|:-|:-|
|void setAttribute(String name, Object value)|지정된 값(value)을 지정된 속성 이름(name)으로 저장|
|Object getAttribute(String name)|지정된 이름(name)으로 지정된 속성의 값을 반환|
|void removeAttribute(String name)|지정된 이름(name)의 속성을 삭제|
|Enumeration getAttributeNames()|기본 객체에 저장된 모든 속성의 이름을 반환|


### 세션의 종료
1. 수동 종료
```
HttpSession session = request.getSession();		
session.invalidate();			
// 1. 세션을 즉시 종료
session.setMaxInactiveInterval(30*60);	
// 2. 예약 종료(30분 후)(초단위)
```

2. 자동 종료 - web.xml
```
<session-config>
	<session-timeout>30</session-timeout> 
    //xml의 30은 분단위(시간)
</session-config>	
```


### 쿠키 vs 세션

|쿠키(Cookie)|세션(HttpSession)|
|-|-|
|브라우저에 저장|서버에 저장|
|서버 부담 X|서버 부담 O|
|보안에 불리|보안에 유리|
|서버 다중화에 유리|서버 다중화에 불리|


#### 만약 쿠키를 허용하지 않게 했음에도 불구하고,,,
* 페이지로 요청하고, 서버로부터 응답을 받고 `페이지 소스'의 form태그를 보면, URL뒤에 세션 ID가 추가되어있다. 
* 쿠키를 허용하지 않는 브라우저에는 모든 URL에 세션ID를 붙여준다.
* 그래서 서버에 요청할 때, 세션 ID가 URL과 같이 전송되도록 해야한다.
* 세션 ID를 일일이 적어주긴 번거로움. 그런데 자동적으로 붙을 수 있는 이유는..
  * form태그 안의  `action="<c:url value="/login/login">"` 태그 때문이다... 특히 `<c:url >` 때문이다.
  * `<c:url >` 태그가쿠키를 허용하지 않는 브라우저일 경우, 세션Id를 자동적으로 세션ID를 붙여준다.
  * 브라우저 중에 쿠키를 허용하지 않는 브라우저도 있기 때문에,,, 뷰 작성시 링크에는 'url'태그를 이용해서 작성해야한다.
  * 그래야 쿠키를 허용하지 않는 브라우저에도 세션 ID를 붙여줄 수 있다.

#### **서버는 첫 번째 요청을 받으면, 세션정보를 두가지 방법으로 브라우저에 전송한다.**
* 브라우저에서 요청/응답 후, 페이지소스를 보면, URL뒤에 세션ID가 붙어있다.
  * 첫 번째 요청에는 서버가 세션ID를 붙여서 보내준다.
  * 브라우저가 쿠키를 허용하는지 안 하는지 모르기 때문이다.
* 응답헤더를 통해서도 세션ID를 붙여 전송한다.
  * 브라우저가 쿠키를 허용할수도, 하지 않을 수도 있기 때문에 두 가지 방법을 통해서 세션ID정보를 알려준다.

* 만약 쿠키를 허용하지 않으면, 서버는 URL뒤에 오는 세션ID를 통해서 같은 브라우저인지 구별한다.
* 그러나 쿠키를 허용하면.. 두번째 요청/응답으론 URL뒤에 세션 ID를 붙이지 않고, 응답 메세지의 쿠키에 세션ID의 정보를 담아서 준다. 
  * 왜냐하면, 요청 메세지를 보면, 이미 세션 ID가 붙은 쿠키를 가지고 브라우저가 서버로 요청을 보내기 때문이다.

> 참고!
만약 form태그에 url태그도 쓰지않고, 쿠키도 허용하지 않으면, 
서버입장에서는 무상태성`(stateless : 브라우저의 정보를 저장하지 않는 성질)`때문에, 똑같은 브라우저의 요청에도 불구하고, 매번 다른 요청으로 받아들이기 때문에, 요청이오면, 세션 객체(저장소)를 계속 생성한다. 
그래서 서버부담이 커진다.
