# JPA(2)

### ※ JPA 사용시 주의사항 
* @Entity 애너테이션과 @Id 애너테이션은 필수다.
* 파라미터가 없는 기본 생성자는 필수로 추가해주어야 한다.
  * 기본 생성자가 없는 경우에 에러가 발생하는 경우가 있기 때문에, 기본생성자는 습관적으로 추가해주는 것이 좋다.
* 중복되는 엔티티 클래스가 없고, 테이블 이름이 클래스 이름과 같을 경우에 @Entity 애너테이션과 @Table 애너테이션에 name 애트리뷰트를 지정하지 않고, 클래스 이름으로 사용하는 게 권장된다.


## 기본키 매핑
* 데이터베이스의 테이블에 기본키 설정은 필수다.
* JPA에서는 `@Id` 애너테이션을 추가한 필드가 **기본 키 컬럼**이 된다. 기본키를 어떤 방식으로 생성해 줄지에 대한 다양한 전략을 지원한다.
  * 기본키 생성 전략
    * 기본키 직접 할당
      * 애플리케이션 코드 상에서 기본키를 직접 할당 해주는 방식
      * `@Id` 애너테이션으로 기본키로 사용할 필드를 지정할 수 있다.
      * 생성자의 매개변수로 기본키로 지정한 필드를 주어서, 기본키를 직접할당하면서 객체를 생성한다.
    * 기본키 자동 생성
      * IDENTITY
        * 기본키 생성을 데이터베이스에 위임하는 전략입니다.
        * 데이터베이스에서 기본키를 생성해주는 대표적인 방식은 MySQL의 AUTO_INCREMENT 기능을 통해 자동 증가 숫자를 기본키로 사용하는 방식이 있습니다.
        * `@GeneratedValue` 애너테이션의 `strategy` 애트리뷰트의 값을 **GenertationType.IDENTITY**로 지정해주면 된다.
      * SEQUENCE
        * 데이터베이스에서 제공하는 시퀀스를 사용해서 기본키를 생성하는 전략입니다.
        * `@GeneratedValue` 애너테이션의 `strategy` 애트리뷰트의 값을 **GenertationType.SEQUENCE**로 지정해주면 된다.
      * AUTO 전략
        * `@Id`필드에 `@GeneratedValue(strategy = GenerationType.AUTO)`를 지정하면 JPA가 데이터베이스의 **Dialect**에 따라서 적절한 전략을 자동으로 선택한다.
          * **Dialect**
            * 표준 SQL등이 아닌 특정 데이터베이스에 특화된 고유한 기능을 의미한다. 
            * JPA가 지원하는 표준 문법이 아닌 특정 데이터베이스에 특화된 기능을 사용할 경우 Dialect가 처리해준다.
      * TABLE
        * 별도의 키 생성 테이블을 사용하는 전략입니다.


> 기본키 직접 할당시에 클래스에 에러가 나온다. 주의 사항처럼 기본생성자를 추가해주니 에러가 사라졌다.


## JPA 관련 애너테이션

#### @Column
- 필드와 컬럼을 매핑해주는 애너테이션.
- 만약 `@Column` 애너테이션이 없고, 필드만 정의되어 있다면 JPA는 기본적으로 해당 필드가 테이블의 컬럼과 매핑되는 필드라고 간주한다. 
  - 이럴 경우, @Column 애너테이션에 사용되는 애트리뷰트의 값은 디폴트 값들이 적용된다.
- 애트리뷰트
  - nullable
    - 컬럼에 null값을 허용할지 여부를 지정
    - 디폴트 값은 true. 
  - updatable
    - 컬럼 데이터를 수정할 수 있는지 여부를 지정
    - 디폴트 값은 true이다.
  - uniqe
    - 하나의 컬럼에 unique(유니크) 제약 조건을 설정한다.
    - 디폴트 값은 false이다.

- `@Column` 애너테이션이 생략되서 애트리뷰트의 값을 기본값으로 사용할 경우 주의 사항
@Column 애너테이션이 생략된 경우 기본적으로 `nullable = true`이다.
그런데 만약 필드의 데이터 타입이 int, long 같은 java 원시 타입이라면 `null 값을 입력할 수 없다.
`null`은 객체 타입일 경우에만 적용되기때문...

Java 원시 타입 필드에서 `@Column` 애너테이션이 없거나 `@Column` 애너테이션이 있지만, 애트리뷰트를 생략한 경우, 최소 nullable=false는 설정하는 것이 에러를 미연에 방지하기에 좋다.




### @Column의 애트리뷰트
* **length**
  * 컬럼에 저장할 수 있는 문자 길이를 지정할 수 있다.
  * 디폴트 값은 255이다.
* **LocalDateTime** 
  * `@Column`의 애트리뷰트는 아니지만, 컬럼의 **TIMESTAMP**타입과 매핑된다.
* **name**
  * name 애트리뷰트로 별도의 이름을 지정해서 엔티티 클래스 필드명과 다른 이름으로 컬럼을 생성할 수 있다. 생략하면, 엔티티 클래스 필드의 이름으로 컬럼이 생성된다.

  
### @Transient
이 애너테이션을 필드에 추가하면 테이블 컬럼과 매핑하지 않겠다는 의미로 JPA가 인식을 한다.
* 그래서 데이터 베이스에 저장도 하지 않고 조회할 때 역시 매핑되지 않는다.
* 이 애너테이션은 주로 임시 데이터를 메모리에서 사용하기 위한 용도로 사용된다.


### @Enumerated
이 애너테이션은 enum 타입과 매핑할 때 사용하는 애너테이션이다.
두 가지 타입을 가질 수 있다.
* EnumType.ORDINAL 
  * enum의 순서를 나타내는 숫자를 테이블에 저장한다.
* EnumType.STRING
  * enum의 이름을 테이블에 저장한다.

* 만약 EnumType.ORDINAL 로 지정하면, 기존에 정의되어 있는 enum사이에 새로운 enum 하나가 추가 되면, 테이블에 이미 저장되어 있는 enum 순서번호와 enum에  정의되어 있는 순서가 일치하지 않게 되는 문제가 발생한다. 따라서 이런 문제가 발생하지 않도록, **EnumType.STRING**을 사용하는 것을 권장한다.  
