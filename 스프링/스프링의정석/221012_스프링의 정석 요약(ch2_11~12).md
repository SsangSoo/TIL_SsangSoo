# Intro..

선생님이 이 강의를 통해서 무엇을 알려주는지 유념하고 강의를 봐야 어떤 것을 알려주려고 하는지, 이해가 된다.
처음엔 들으면서, 원리 설명인데, 이 코드들이 과연 무슨 상관이 있는지 몰랐다... 
코드를 복사 붙여넣기 해서 설명을 해주시는데, 지금 뭔가 잘 못 된 거 같았다.

그리고 강의 초반부에 선생님께서
"이번 시간에는~~ 알아보겠습니다. ~~먼저 깃허브 가셔서요~.~~" 이렇게 시작하신다..
그리고, 11강에서 알려주시려 하는 내용은

> 스프링이 내부적으로 어떻게 동작하길레, 매개변수만 적어주면 알아서 처리하게 되는지..

이었다.. 그리고 다시 찬찬히 봤던 강의들을 복기했다..  코드가 스프링코드가 아니라,
완전 단순화 시켜서 스프링의 내부 `원리`를 알려주시려 하셨던거엿다..

~~학습 목표가 이렇게 중요하군..;;;공부 잘 하는 사람은 이유가 있다..;;~~

여튼 그걸 이해하고 보니, 머리에 잘 들어와서 12시부터 1시까지 점심시간인데, 그냥 냅다 달리고 있다. 후후..

머리에 들어오니 기분이 좋다. 

```
나는 잘 되고 있다. 곧 잘 될 것이다. 이미 잘 되기도 했다.
```


---

# ch2_11


스프링이 내부적으로 어떻게 동작하길레, 매개변수만 적어주면 알아서 처리하게 되는지에 대한 원리

`MethodInfo` 예제

>Spring이 매개변수의 정보를 어떻게 불러오는지의 흐름.
해당 예제는 Reflection API를 이용한다.
* 코드를 통해서 흐름을 이해해야 한다.

자바 컴파일러는 매개변수 타입은 저장하지만, 굳이 매개변수의 이름을 저장하진 않는다.
매개변수의 이름을 지정하려면, `javac -parameters` 옵션을 이용해야 한다. (Java 8부터..)

* 스프링이 '매개변수 이름'을 얻어오는 두가지 방법
  1. Reflection API
    * Java 8(jdk 1.8버전 이후 `-parameters` 옵션을 줌으로써 읽어올 수 있음)
    * 그런데, 스프링은 1.8 버전 이전에도 써왔는데, 그 전에는 어떻게 읽었을까?
  2. class file
    * 1.8 버전에는 class파일을 통해서 매개변수의 이름을 얻어왔다.
    
스프링이 처음엔 Reflection API를 이용해서 읽어오고, 후에, class 파일을 통해서 매개변수 이름을 얻어온다.



---
`MethodCall` 예제

 Model, Controller, view의 흐름 / 코드를 통해서 스프링 흐름을 이해해야 한다!
내가 이해하기론 다음과 같은 흐름으로 생각한다. (틀릴 수도 있다. 태클 감사.)
- main메서드가 DispatcherServlet 역할을 한다고 본다. Model역할을 하는 Map을 생성하고,
- ModelContoller는 Model 객체를 받아서, 요청으로부터 받아온 데이터를 처리해서 Model에 값을 넣고,
view 이름 반환하는 Controller역할을,
- render메서드는 view 정보를 받아서 브라우저에 출력.



> 참고 : 다른 형식의 파일(예: *.txt)이 필요할 때, 파일 경로는 
프로젝트(ch2 프로젝트라면, ch2 디렉터리) 디렉터리로 지정한다. 
스프링과 상관없다. 인텔리제이는 어떻게 될지 모르겠다.
* 중요한 건 아님.


> 참고 : 해당 프로젝트는 Maven을 통해서 관리한다.
pom.xml은 Maven과 관련된 설정이다.

---

# ch2_12

> MethodCall2 => MehthodCall1 흐름과 같지만, 조금 변형함.

MethodCall2 에서 main메서드 내에 아래와 같은 코드가 있다.

```
// Strint viewName = obj.main(2021, 10, 1, model); // class정보를 얻어서 main메서드를 호출 // 아래 줄과 동일한 기능.
String viewName = (String)main.invoke(obj, new Object[]{2021, 10, 1, mode }); // Reflection API를 이용한 main메서드 호출 
```

>이전 예제와 똑같은 내용이지만, 이번 예제는 Reflection API를 이용.
이번 예제의 render는 txt파일을 보여주는 것과는 다르게, jsp파일을 읽어서 보여줌.


---

MethodCall3
이전 예제에선 하드코딩 했던 부분을, 이번 예제에서는 요청할 때 넘어온 값을 이용해서 객체배열을 생성할 수 있도록 동적으로 구성함.


* 예제의 가장 상단의Map 관련 4줄의 코드 = > 요청할 때 넘어온 값(`reqeust.getParameterMap()` 와 같은 결과를 가진다고 생각하면됨)
* 반복문 안에 `converTo(value, paramType)`은 String으로 받아온 값을 메서드의 형식에 맞게 형변환헤서 넣어준다.


---

MyDispatcherServlet - MethodCall3를 원격프로그램으로 만든 예제

@WebServlet 
* 오류 해결 방법 두 가지
  * pom.xml 변경
  * Tomcat Library import 방법이 있음,
* @WebServlet = @Controller + @RequestMapping
  * 스프링은 클래스 앞에 @Controller / 메서드 앞에 @RequestMapping을 붙여줌.
  * 서블릿은 메서드 단위로는 매핑을 할 수 없고, 클래스 단위로만 매핑가능하다. 그래서 상대적으로 스프링보다 클래스를 더 많이 만들 수 밖에 없다.

**서블릿**
잠깐 언급.
* 반드시 해야 될 것들
  * HttpServlet을 상속받아야하고,
  * 메서드이름은 service로하되 매개변수로 HttpServletRequest, HttpServletResponse를 받아야 한다. (심지어 @Override...;;)
`참고로 서블릿 다음 강의부터 4강 장전 되어있다.`


예제 코드들은 스프링의 정석 GitHub에 있다.. 
코드를 아예 박제하는 건 그렇게 좋진 않은 듯..
