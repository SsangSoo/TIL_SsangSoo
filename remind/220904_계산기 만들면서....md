계산기를 만들었다
_~~빡...치진 않았다..모르겠다..여튼 어렵다..근데 다음엔 좀 빨리 만들 것 같다..~~_

코드스테이츠 과제로 계산기를 만드는 과제를 원래 목요일에 했어야했지만, 쉽게 보고, 코드를 작성하다가 안 되서, 이건 날잡고, 시간 잡고, 각 잡고 해야되겠다고 생각했다...
그리고 토요일 24시부터 일요일 AM.2시 30분까지 갈아넣었다..
시계 봤을 때, 1시가 가까운 시간이었지만,,1시전이었다. 근데 갑자기 보니깐 1시 46분되있더라..
(_~~그래.. 졸았다..~~_ 생각처럼 안되길레 뭐가 문제지하면서 보는데 졸았다..)
후.. 여튼 오늘 어디 좀 갔다가 이래저래 뭐하다가 샤워하고 나오니 11시쯤이었다..
유레카를 외쳤던 인물이 생각이 안난다...근데 유레카를 외친 곳이 욕실인걸로 기억하는데, 나는 샤워하면서 계산기를 만들 생각을 하였고, 물 맞다보니 계산기 로직이 떠올랐다._~~(근데 그 생각처럼은 안 되었다..ㅋㅋ)~~_

나는 코드를 작성할 때, 나의 레벨에 맞지않는 생각을 한다.. 다른 사람이 그렇게 하길 노력한다고 하는 걸 봤기 때문에..신경 쓰게 되었다. 그게 무엇이냐면...
코드를 작성하는데 첨부터 코드의 간결성이나 이쁜 걸 생각하는 거다... 사실 몰랐지만, 무의식적으로 내가 그렇게 생각하더란 것.. 그리고 그걸 알고, 자바의 정석 _~~공식인듯, 공식 아닌, 공식 같은~~_ 비공식 스터디의 오픈챗이 있다._~~(지금 보니 327명이 있다..ㄷㄷ;;)~~_

거기다 물어보았다.. 내가 지금 이런 생각을 하는데,, 이게 지금 제가 버려야되는 생각 아닙니까? 라고 했다.

근데 내가 지금 그걸 생각할 레벨이 아닌 건 당연하다..그래서 아직 그거 생각할 레벨 아니라고 하시더라...ㅋㅋㅋㅋㅋㅋ

그리고 그 분이 심금을 울리는 한 마디를 했다..

```
코드도 더럽게 작성해봐야 비로소 깨끗해집니다.
```

라고.. ~~_이야~ 무슨..개발계의 명언 제조기신줄.._~~

여튼 계산기 로직에서 Scanner를 통해서 문자열을 입력받고, 공백이 있다면, 공백을 없애고, 연산자가 있는지 없는지 확인해서, 연산자를 기준으로 왼쪽은 피연산자1, 연산자 기준 오른쪽은 피연산자2로 했는데, 코드가 일단 더러워져도 된다고 한 말에

나는 연산자를 (4칙연산 기준) if문에 일일이 다 넣어서, 만약에 "+"라면? 만약에 "-"라면? 만약에 "*"라면? 만약에 "/"라면? 
등 , 그렇게 연산자에 따라서 코드를 일일이 중복되더라도 다 쓸 판국이었다..
그런데.. 뭔가 보이기 시작하더니 알 수 없는,,,뇌에서 뭔가 작요이 일어나면서 연산자를 아예 for문으로 해버리고, 연산자를 찾아서, 그 연산자를 하나의 문자형 변수에 넣고 그 문자형 변수를 if에 집어넣으면 그 연산자를 찾는데, 중복코드를 쓸 필요가 없어질 것 같은 느낌을 받았다..
아니나 다를까...
for문 안썻으면,, 100줄도 안되서 작성하는 코드가.. 200줄을 넘었을거라. 예상한다..

여튼 거기 오픈챗에 아직 안주무시고 계신 정수기 필터 회사같은 닉넴을 가지신 른코이웨이 님께서 약간 조정해주셨고, 더 효율적인 방법을 말해주셔다. 
내가 의사코드를 적고, 나름 코드작성을 해서, do-while문을 나중에 작성했는데, 그 와중에 변수까지 덮어버리더라..그래서 ㅋㅋㅋㅋㅋ
변수를 빼세요~ 하다가. 더 효육적이게 완성되긴 했는데...
(사실 더 사용자 친화적이어야되고, 바로 바로 연산이 되게 만들어야 하는데,, ㅠㅠ나는 일단 피연산자 2개로만으로도 잘 계산 되도록 하는 것이 목적이었기 때문에.. 일단 다음에 잘하겠다고 했다...)

그래도 이렇게 삽질을 해봤기 때문에, 삽질이 더 쉬워질거라 생각된다... 
~~(새벽 3시에 글 쓰고 있는데... 쓰다가 잠온다 ㅠㅠ)~~
여튼 오늘도 나름 많이 먹었다..기분이 좋다 흐흐... 

코드결과는 대충 이렇다....![](https://velog.velcdn.com/images/tjdtn4484/post/5db6bc93-de2f-4a75-8ed7-16a655484bce/image.png)

사실.. 저거말고도, 많은 연산상황이 있지만, 일단 피연산자 두개로 하나의 연산을 하는데 신경썻고, 계산을 계속 할건지 말건지 물어보는 여부를 구현해봤다...

```
package com.codestates.seb.calculator;
import java.util.Scanner;

public class Calculator {
    public static void main(String[] args) {
        System.out.println("===Java Calculator===");

        Scanner input = new Scanner(System.in);
        /*
            요구 사항에 따라 간단한 계산기를 만들어주세요.
            1. 사용자의 입력으로 첫 번째 숫자, 연산자, 두 번째 숫자를 받아야 합니다.
            2. 연산자의 종류는 +, -, *, / 입니다.
            3. 소수점 연산을 수행할 수 있어야 합니다.
            4. 연산 결과를 콘솔에 출력합니다.
        */
        // TODO...
        double num1 = 0;        // 왼쪽 피연산자
        double num2 = 0;        // 오른쪽 피연산자.

        double result = 0;      // 피연산자의 결과.
        String[] operArr = {"+", "-", "/", "*"};   // 연산식을 배열에 담음.
        String oper = "";                       // 연산식을 담을 문자열 변수 oper

        do {
            System.out.println("연산을 수행하십시오(피연산자 2개) : ");

            String exp = input.nextLine();          // 식을 입력받아 문자열로 저장.

            // 식으로 받은 연산식에 공백이 있으면 공백 제거,
            if (exp.contains(" ")) {
                exp =  exp.replaceAll(" ","");
            }

    // 포문으로 exp의 연산식을 확인
            for (int i = 0; i < operArr.length; i++) {
                if (exp.contains(operArr[i])) {
                    oper = operArr[i];      // 무엇인지 찾았으면, oper에 저장하고,
                }
            }
//       공백이 제거된 문자열에서 연산식을 찾아서 인덱스를 받고, 그 인덱스의 문자를 무슨 연산식인지 확인하고, 계산
                int ex = exp.indexOf(oper);                              // 문자열로된 연산식의 인덱스를 반환하고,

                // 왼쪽 피연산자.
                if (exp.substring(0, ex).contains(".")) {                 // 연산식의 왼쪽 문자들을 수로 변환할 때, 소수점이 있는지 확인..
                    // 소수점을 기준으로, 왼쪽은 정수로, 오른쪽은 0.xxx로 반환할 건데... 소수점의 인덱스를 확인.
                    int point = exp.substring(0, ex).indexOf(".");
                    int num1int = Integer.parseInt(exp.substring(0,point));            // 소수점 왼쪽은 num1의 정수로,
                    double num1double = Double.parseDouble(exp.substring(point, ex));  // 소수정 오른쪽은 num1의 실수로,
                    num1 = num1int + num1double;                       // 왼쪽 피연산자를 구함.
                } else {                                               // 소수점이 없다면,
                    num1 = Double.parseDouble(exp.substring(0, ex));   // 연산자 기준의 왼쪽 수를 num1에 저장
                }

                // 오른쪽 피연산자. 연산자의 인덱스가 ex이기 때문에, num2이 인덱스 시작은 ex+1..
                if (exp.substring(ex+1).contains(".")) {             // 연산식의 기준 오른쪽에 있는 수가 소수라면,
                    // 소수점을 기준으로, 왼쪽은 정수로, 오른쪽은 0.xxx로 반환할 건데... 소수점의 인덱스를 확인.
                    int point = exp.lastIndexOf(".");                        // 오른쪽 피연산자의 연산식의 뒤에서부터 index를 찾아야 됨.
                    int num2int = Integer.parseInt(exp.substring(ex+1, point));  // 소수점 왼쪽은 num2의 정수로,
                    double num2double = Double.parseDouble(exp.substring(point+1));  // 소수점 오른쪽은 num1의 실수로, 소수점이후부터, 끝까지
//                    num2double의 수의 개수만큼 10의 거듭제곱을 나눠준다.
                    num2double = num2double / Math.pow(10, exp.substring(point+1).length());

                    num2 = num2int + num2double;                       // 오른쪽 피연산자를 구함.
                } else {                                               // 소수점이 없다면,
                    num2 = Double.parseDouble(exp.substring(ex+1));      // 연산자 기준의 오른쪽 수를 num2에 저장
                }

            // 연산자에 따라 연산결과. 반환(스위치)
            switch (oper) { // oper에 따라 연산.
                case "+": result = num1 + num2;
                    break;
                case "-":  result = num1 - num2;
                    break;
                case "*":  result = num1 * num2;
                    break;
                default:  result = num1 / num2; // '/'
                    break;
            } // switch
//            연산 결과를 출력한다. 만약에 소수점이 없는 정수라면, 정수를,, 소수점이 있는 실수면 그냥 출력
//            연산식에 따라 연산 결과를 출력하는데,, 만약 소숫점 아래 수가 없다면, int로 형변환해서 출력, 아니면 그냥 출력
            if(result-(int)result==0) {
                System.out.println("연산자는 '" + oper +"'이고, 연산결과는 " + (int)result + "입니다..");
            } else {
                System.out.println("연산자는 '" + oper+ "'이고, 연살결과는 " + result + "입니다.");
            }

            // 다시 계산 할지 여부.
            System.out.println("계속하시려면 y(대소문자 구분 없음)를 입력하하세요.");

            if(input.nextLine().equalsIgnoreCase("y")) { // y를 입력받으면(대소문자 구별 X)
                System.out.println("연산을 다시 시작합니다.");
            } else {
                System.out.println("종료로 간주하고, 계산기를 종료합니다.");
                break;
            }
        } while(true);
      }// main
} // class끝
```

여튼 이런식으로 만들었다..
사실 구현할 내용들은 생각하다보면 많다. 멘트도 더 사용자 친화적으로 바꾸고,' 연산자가 없을 경우,? 어떻게 처리할지,,"  등등 많이 추가할 내용들은 많다만... 일단.. 오늘 여기까지만 하기로 했다. 

for문도 사실 코드를 보다보니 "이렇게 해도 되겠는데? "해서 사용해보았다(연산자가 무엇인지 알아낼 때..)

일단 다른 기능들은 다음에 추가해보자...
오늘은 여기까지..ㅎ

> 어차피 잘 될 나..

