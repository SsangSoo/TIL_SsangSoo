# ch2_6
* server.xml
  * 톰캣설치경로/conf/server.xml : Tomcat 서버 설정 파일
  * xml 구조가 마치 Tomcat 내부구조형식으로 이루어져있음.

* web.xml
  * 톰캣설치경로/conf/web.xml : Tomcat의 모든 web app의 공통설정
    * 원격 프로그램을 사용하려면, 
```
1. 원격프로그램 등록(=서블릿등록)
2. URL 연결
```
위 두가지 내용을 원래 이 web.xml 로 설정했었지만, 지금 애너세이션으로 기반으로 바뀌고 있다.
```
1. @Controller
2. @RequestMapping
```

* 웹앱이름/WEB_INF/web.xml : web app의 개별 설정
  * 여기서도 역시, 원격프로그램 등록하는 부분과 URL맵핑하는 부분이 있음. 하지만 이 역시 애녀테이션 기반으로 바뀌고 있다.

---

# ch2_7





### Protocol
* 서로 간의 통신을 위한 약속, 규칙
* 주고 받을 데이터에 대한 형식을 정의한 것


#### HTTP(Hyper Text Transfer Protocol)
* 텍스트(HTML)를 전송하기 위한 프로토콜
* 단순하고, 읽기 쉬움 - 텍스트 기반 프로토콜
* 상태유지를 하지 않는다.(Stateless) - 클라이언트 정보를 저장 X.
  * 같은 클라이언트가 요청을 같은 서버로 여러번 보내더라도, 같은 클라이언트인지 구별하지 못함. 
  * 상태유지를 하지 않기 때문이다. 즉, 정보를 저장하지 않기 때문이다.
  * 이를 보완하기 위해 쿠키와 세션을 사용.
* 확장 가능 - 커스텀 헤더(header) 추가 가능
  * 형식 
    * 한 줄, 한 줄 다 header
    * 헤더이름 : 값 (공백은 무시)
    * 대소문자 구분 안 함.
    * header는 여러개 나올 수 있음. 

`1. 우리는 URL을 브라우저의 주소창으로 치고, 엔터를 치지만, 브라우저가 자동으로 **HTTP 요청메세지**를 만들어 서버로 전송.`
`2. 서버는 받아서 응답메세지(응답헤더+응답바디)를 브라우저전송하고, 브라우저가 응답메세지를 해석해서 화면에 출력해준다.`

* HTTP 응답메세지 형식
  * 헤더
    * status line(상태 라인)
      * 프로토콜 ex)HTTP/1.1 
      * 상태코드 ex) 200
      
|상태코드|의미|
|:---:|:---:|
| 1xx |Informational <br> HTTP/1.1부터 추가, 서버와 클라이언트의 정보교환 목적 |
| 2xx |Success <br> 성공|
| 3xx |Redirect  <br> 다른 URL 요청|
| 4xx |Client Error |
| 5xx |Server Error |


     * 상태코드에 대한 설명 ex) OK, ... etc.. 
  * 빈줄
    * 헤더와 바디를 구분한다.
  * 바디
    * 응답 내용
    

##### HTTP 요청 메시지 
* GET
  * READ에 가까움.
  * 서버에 리소스를 요청해서 얻어오고, 읽어오기 위한 메서드.
  * 데이터를 보낼 것이 있으면, 쿼리 스트링으로 보낼 수 있다.
  * 바디가 없음, 즉 헤더만 있음.(Only Header)
  * 구성 요소
    * 요청라인(request line)
    * 헤더
    * 빈줄(헤더/바디 구분)
  * URL에 데이터가 노출되어서 보안에 취약
  * 반면에, 데이터 공유에 유리하다.

* POST
  * Write에 가까움(쓰기)
  * 서버에 전송할 data를 바디에 담고있음.
  * 구성요소
    * 요청라인(request line)
    * 헤더
    * 빈줄(헤더/바디 구분)
    * 바디
  * data를 body에 담아 전송하므로, 보안 유리
    * 보안에 유리하다하지만, 페이지 검사를 통해서 사실은 볼 수 있다.
    * 그래서 HTTPS(HTTP+TLS)로 암호화를 하여, 데이터를 보내야한다.
      * TLS는 참고로, SSL의 신버전..
  * 반면에, 데이터 공유에는 불리.



# ch2_8

* 파일
  * 텍스트 파일
    * 읽기 쉽다.
    * 문자만 저장되어 있는 파일
  * 바이너리 파일
    * 문자+숫자가 저장되어 있는 파일
>바이너리 파일과 텍스트 파일의 구분방법 : 읽을 수 있으면 텍스트 파일 못 읽으면 바이너리 파일... 왜냐하면 글자가 깨짐.

* 파일 쓸 때(Write)
  * 바이너리 파일
    * 데이터를 있는 그대로 읽고 쓴다.
    * 문자는 문자로, 숫자도 문자와 같이 숫자로 쓴다.
      * 예시
        * AB12 12  > 'A' 'B' '1' '2' [ 0C (= 왼쪽의 숫자 12의 16진수) ]
  * 텍스트 파일
    * 바이너리 파일과 같이 문자는 문자로 읽고 쓰지만, 숫자 또한 문자로 변환하여 쓴다.
      * 예시    
        * AB12 12> 'A' 'B' '1' '2' '1' '2' 
        * 문자나 숫자나 한 글자 한 글자 ASCII 코드로 변환. 

* 파일을 읽을 때(Read)
  * 바이너리 파일
    * 문자 -> 문자
    * 숫자 -> 숫자
  * 텍스트 파일
    * 문자 -> 문자
    * 문자 -> 숫자


### MIME(Multipurpose Internet Mail Extensions)
`텍스트` 기반 프로토콜에 바이너리 데이터를 전송하기 위해 고안된 것.
HTTP의 Content-Type헤더에 사용. 데이터의 타입을 명시

```
텍스트 기반이라고 해서 텍스트만 가리키는 것이 아니라, 
텍스트 기반에서 ,이미지, 동영상 등과 같은  바이너리 파일을 어떻게 전송하는가..
```
를 위해서 고안된 것.

|타입|설명|MIME타입 예시(타입/서브타입) |
|:-|:-|:-|
|text|텍스트를 포함하는 모든 문서|text/plain, text/html, text/css, text/javascript|
|image|모든 종류의 이미지|image/bmp, image/webp|
|audio|모든 종류의 오디오 파일|audio/midi, <br>  audio/mpeg,  <br> audio/webm, <br>  audio/ogg,  <br> audio/wav|
|video|모든 종류의 비디오 파일|video/webm,  <br> video/ogg|
|application|모든 종류의 이진 데이터|application/octetstream,  <br> application/pkcs12, <br> application/vnd,mspowerpoint, <br> application/xhtml+xml,  <br> application/xml, <br> application/pdf|

*데이터 타입을 명시?
(HttpServletResponse response)를 매개변수로 받고, 
```
response.setContentType("text/html"); 
```
위와 같은 코드에서 타입을 명시할 때, 괄호 안의 내용으로 MIME타입을 쓴다.

요청 메세지 POST방식에서, 중간에 'Boundary"가 쓰여 있는 문자열을 기준으로, Text data와 binary data를 구분한다.

##### request.getHeaderNames() 메서드
해당 메서드가 Enumeration을 반환하고, Iterator처럼 다음 요소를 확인하면서, 값을 불러낸다.
> Enumeration은 Iterator은 구 버전...

GET과 POST의 차이점
* 전송할 데이터가 Header에 있는가, Body에 있는가차이..

* request.getRequestURI()
  * QueryString(=전송할 데이터)
* request.getMethod()
  * GET인지, POST인지.
* request.getProtocol()
  * HTTP/1.1인지 아닌지..


### Base64
64진법을 사용.
'0' ~ '9' : 10개,
'A' ~ 'Z' : 26개
'a' ~ 'z' :  26개

----------------
62개

'+' '/'    
2개

-----------------
총 64개 
---

64 = 2^6
총 64개의 문자를 6bit로 구성.

무슨 말이냐..
```
	M		|		a	   |
01001101	|   01100001   |
010011 | 010110 | 0001 00(자르다가, 모자란 부분 0으로)| 
|  T    |   W   |   E     |  =(Padding)  |
----------------------------------------------
```
이런식으로 하나의 문자를 8bit(0~127)로두고, 그 문자들을 6bit로 잘라서 자른 6bit의 수를 다시 Base64의 문자들로 변환해서 저장한다.

Base64는 모든 인코딩의 공통적인 부분이기 때문에, 서로 다른 인코딩형식을 가지는 OS를 가지는 PC끼리 데이터를 전달해도 문제가 없다.
다만, 16bit의 문자를 6bit로 맞추다보니, 24bit로 늘어나서 데이터가 늘어나는 단점이있다.

---

ch2_8은 이제 안 들어도 될것 같다...
~~사실 앞의 내용도...곧 코드구현 겁나게 할 예정이다..~~



나는 HTTP 요청메시지나, HTTP 응답메시지나, 둘다 GET메서드, POST메서드가 있는 줄 알았지만, 요청 메세지에만, GET과 POST만 있었다니...
![](https://velog.velcdn.com/images/tjdtn4484/post/8e55020f-ae28-4cbd-8527-af9f6bef8ea0/image.png)

그래도 또 소확지(소소하고 확실한 지식)가 채워졌다..

~~선생님의 은혜에는 차마 중간 줄을 못 치겠다. 선생님의 은혜에 줄긋기라니..나 같지 않다...~~
테이블이 처음에 찐따 같이 나와서 선생님한테 여쭤봤다. 근데 선생님이`<br>` 태그를 쓰면 된다고한다.
`<br>` << 이거 그대로 홑 따옴표로 안 붙이고, 사용하면, 포스팅시 그냥 삐얼(br:줄바꿈된다).. 
여튼 테이블에 줄을 바꾸면서 글을 넣고 싶다면, 우리 모두 `<br>`을 쓰자..
이 지식을 알게 해준 LJY님께..~~쌩수올림~~


>나는 잘 되어가고 있고 , 더 잘 될 놈이다.
