# 데이터베이스(DB)
~~DB하니깐 디비자고싶다...~~

오늘 너무 열받았다..아니 열받기보다, 음.. 어 나한테 좀 킹받았다..
9시 세션 전부터 한시간동안 씨름했던, 문제가 있었다.. 결론적으로 풀었다마는,, 근데 해당메서드를 재귀로 돌리라고 하더라... 
한 숨을 쉬었다...
9시30분부터였다.. 다시 쌔빠지게 했다... 12시30분이 지났다...
그래.. 미련해보일 수 있다... 근데, 우야노..ㅠㅠ 끝이 보일 것 같은데,,,,
적다보니 허벌나게 미련했네..
여튼 나도 좀 힘들었는지... 12시 40분쯤 같이 교육참여하시는 동기분께 여쭤봤다... 
"해당문제 저번에 풀었던 재귀파트의 마지막 문제에요~"라 하셨다..
나는 흠.. 내가 못 푼 문제 아닌가? 싶었다. 왜냐하면, 자료구조/알고리즘에 하도 뚜까맞아서...
근데,, 하.. 나 그거 풀었더라...?
인생무상......

어차피 잘 될거지만, 흠.. 
> 어차피 잘 될거다.. 걱정말자... 가끔 이런 날 있어야 인생 아이것나...하하하..

![](https://velog.velcdn.com/images/tjdtn4484/post/7073cf92-5c80-4166-9a4a-902bb507d41f/image.png)


재귀shake(셰잌)귀...~~새끼~~
좀만 기다려라 조만간 털러간다...


----


## SQL
* Structured Query Language의 준말
* DB언어로, 관계형 데이터베이스(RDBMS)에서 주로 사용.

##### Query?
* 뜻 : 질의문
* 데이터베이스용 프로그래밍 언어.
* 데이터베이스에 쿼리를 보내서 원하는 데이터를 가져오거나 삽입할 수 있다.

##### NoSQL
* SQL을 사용할 수 있는 데이터베이스와 달리, 데이터의 구조가 고정되어있지 않은 데이터베이스
* 데이터 저장시 데이터베이스처럼 테이블을 사용하지 않고, 다른 형태로 저장함.
* 주로 MongoDB와 같은 문서지향 데이터베이스..

이처럼, NoSQL과 같이 구조가 고정되어있지 않은 데이터베이스도 있기 때문에, SQL의 S가 가지는 의미대로 데이터의 구조가 고정되어있어야한다.


#### 데이터베이스 생성
```
create DATABASE 데이터베이스_이름;
```

#### 데이터베이스 사용
* 데이터베이스로 테이블을 만들거나 수정하거나 삭제하는 등의 작업을 하려면, 데이터베이스를 사용하겠다는 선언을 해야함.
```
use 데이터베이스_이름;
```

#### 테이블 생성
* `USE`를 이용해서 데이터베이스를 선택했다면, 테이블 만들 수 있음.
  * 예시로 user라는 테이블을 만든다고 가정하면, 테이블은 필드와 함께 만들어야 한다. 가정.
|필드 이름| 필드 타입 | 그 외의 속성 |
|---|---|---|
|id|숫자|Primary key이면서 자동 증가되도록 설정|
|name|문자열(최대 255개의 문자)||
|email|문자열(최대 255개의 문자)||

``` 
create TABLE user (
  id int PRIMARY KEY AUTO_INCREMENT,
  name varchar(255),
  email varchar(255)
);
```

#### 테이블 정보 확인

```
DESCRIBE user;
```
```
mysql> describe user;
+-------+--------------+------+-----+---------+----------------+
| Field | Type         | Null | Key | Default | Extra          |
+-------+--------------+------+-----+---------+----------------+
| id    | int          | NO   | PRI | NULL    | auto_increment |
| name  | varchar(255) | YES  |     | NULL    |                |
| email | varchar(255) | YES  |     | NULL    |                |
+-------+--------------+------+-----+---------+----------------+
3 rows in set (0.00 sec)
```
위와 같은 식으로 user테이블의 정보를 확인 가능..


##### SELECT
> 데이터셋에 포함될 특성을 특정

* 일반 문자열

```
SELECT 'hello world'
```
  
* 숫자
```
SELECT 2
```

* 간단한 연산
```
SELECT 15 + 3
```


#### FROM
* 테이블과 관련한 작업 필요시 반드시 입력해야함. FROM 뒤에 결과를 도출할 데이터베이스를 명시
```
SELECT 특성_1
FROM 테이블_이름
```
▲ 특정 특성을 테이블에서 사용
```
SELECT 특성_1, 특성_2
FROM 테이블_이름
```
▲ 몇 가지의 특성을 테이블에서 사용

```
SELECT *
FROM 테이블_이름
```
▲ 테이블의 모든 특성을 선택

> '*' 는 와일드 카드(wildcard)로 전부 선택할 때에 사용


#### WHERE
* 필터 역할을 하는 쿼리문. WHERE은 선택적으로 사용가능

```
SELECT 특성_1, 특성_2
FROM 테이블이름
WHERE 특성_1 = "특정 값"
```
▲ 특정 값과 동일한 데이터 찾기

```
SELECT 특성_1, 특성_2
FROM 테이블_이름
WHERE 특성_2 <> "특정 값
```
▲ 특정 값을 제외한 값을 찾기


```
SELECT 특성_1, 특성_2
FROM 테이블 이름
WHERE 특성_1 > "특정 값"

SELECT 특성_1, 특성_2
FROM 테이블 이름
WHERE 특성_1 <= "특정 값"
```
▲특정 값보다 크거나 작은 데이터를 필터할 때에는 '<', '>', 비교하는 값을 포함하는 '이상','이하' 값은 '<=','>='을 사용.

``` 
SELECT 특성_1, 특성_2
FROM 테이블_이름
WHERE 특성_2 LIKE "%특정 문자열%"
```
▲ 문자열에서 특정 값과 비슷한 값들을 필터할 때에는 'LIKE'와 \%'혹은 '\*'을 사용.

```
SELECT 특성_1, 특성_2
FROM 테이블_이름
WHERE 특성_2 IN ("특정값_1","특정값_2")
```
▲ 리스트의 값들과 일치하는 데이터를 필터할 때에는 'IN'을 사용.

```
SELECT * 
FROM 테이블_이름
WHERE 특성_1 IS NULL
```
▲ 값이 없는 경우 'NULL'을 찾을 때에는 'IS'와 같이 사용

```
SELECT *
FROM 테이블_이름
WHERE 특성_1 IS NOT NULL
```
▲ 값이 없는 경우를 제외할 때에는 'NOT'을 추가해 이용한다.


#### ORDER BY 
* 돌려받는 데이터 결과를 `어떤 기준으로 정렬`하여 출력할지 결정한다. (선택적으로 사용)
```
SELECT *
FROM 테이블_이름
ORDER BY 특성_1
```
▲ 기본 정렬은 오름차순

```
SELECT *
FROM 테이블_이름
ORDER BY 특성_1 DESC
```
▲ 내림차순으로도 정렬 가능
~~(이건.. 써놓고 보니 당연...)~~

#### LIMIT
* 결과로 출력할 데이터의 갯수를 정할 수 있음. (선택적으로 사용)
* 쿼리문에서 사용할 때 가장 마지막에 추가.

``` 
SELECT *
FROM 테이블_이름
LIMIT 200
```
▲ 데이터 결과를 200개만 출력

#### DISTINCT
* 유니크한 값을 받고 싶을 때 `SELECT DISTINCT`를 사용
```
SELECT DISTINCT 특성_1
FROM 테이블_이름
```
▲ 특성_1을 기준으로 유니크한 값들만 선택

```
SELECT 
  DISTINCT
    특성_1
     , 특성_2
     , 특성_3
FROM 테이블_이름
```
▲ 특성_1, 특성_2, 특성_3의 유니크한 '조합 값들을 선택.

#### INNER JOIN
* `INNER JOIN`이나 `JOIN`으로 실행할 수 있음
```
SELECT *
FROM 테이블_1
JOIN 테이블_2 on 테이블_1.특성_A = 테이블_2.특성_B
```
▲ 둘 이상의 테이블을 서로 공통된 부분을 기준으로 연결

#### OUTER JOIN
* `Outer JOIN`은 다양한 선택지가 있다.
```
SELECT * 
FROM 테이블_1
LEFT OUTER JOIN 테이블_2 ON 테이블_1.특성_A = 테이블_2.특성_B
```
▲ 'LEFT OUTER JOIN'으로 LEFT INCLUSIVE 실행

```
SELECT * 
FROM 테이블_1
RIGHT OUTER JOIN 테이블_2 ON 테이블_1.특성_A = 테이블_2.특성_B
```
▲ 'RIGHT OUTER JOIN'으로 RIGHT INCLUSIVE을 실행.


#### 여러 쿼리문 한번에 쓰기
* Brazil에서 온 고객을 도시별로 묶은 뒤에, 각 도시 수에 따라 내림차순으로 정렬. 
* Customerld에 따라 오름차순으로 정렬한 3개의 결과만 요청하는 예시.
> 같은 결과를 출력하는 서로 다른 쿼리문이 있을 수 있음. 같은 결과를 다른 방법으로도 표현 가능.


```
SELECT c.Customerd, c.FirstName, count(c.City) as 'City Count'
FROM customers AS c
JOIN emplyees AS e ON c.SupportRepId = e.EmployeeId
WHERE c.Country = 'Brazil'
GROUP BY c.City
ORDER BY 3 DESC, c.CustomerId ASC
LIMIT 3
```
▲여러 쿼리문을 한 번에 써보기 

